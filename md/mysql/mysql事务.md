MySQL事务

#  ACID 

![](E:\2020\code\springboot_dubbo\tools\md\mysql\img\ACID.png)

## 1、redo log 和undo log

 ![](E:\2020\code\springboot_dubbo\tools\md\mysql\img\原子性实现undolog.png)

#### 正常事务的执行流程

修改一条记录的顺序是：如把id为1的记录的age=1修改成2

```css
1. 事务A 开始
2. undo 记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句
4.记录redo log age=2
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

##### redolog和事务谁优先写入磁盘数据？

其中，redo日志必须先于数据写入磁盘（即步骤5和步骤6的顺序不能改变）。因为如果不这样，在数据提交之后再写redo日志，一旦redo日志的写入过程出现异常，将无法保证持久性。

记录redo日志时，先记入redo log buffer，最后再一起写入磁盘，这样可以减少IO，提升性能。

另外，未提交的事务和回滚了的事务也会计入redo日志。

#### 回滚的事务提交过程

```
1. 事务A 开始
2. undo 记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句
4.记录redo log age=2
---- 这时出现异常回滚
+1 将age修改回1
+2记录 redo log
-----
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

回滚提交的事务，首先会根据先后顺序的逆序把值改回原来的，然后再记录redo log，其实就是多了这两步操作

#### checkpoint机制

redo日志会随着时间推移而越来越大，为了提升redo的恢复性能，引入了**checkpoint机制**，在恢复的时候，只需要从checkpoint的位置往后恢复即可。

------

#### MySQL恢复策略

mysql的恢复策略是：

1. 恢复时，先根据**redo**重做所有事务（包括未提交和回滚了的）
2. 再根据**undo**回滚未提交的事务。

比如上面事务A未提交事务的时候宕机，恢复时，先根据redo日志将数据恢复为age=2，然后根据undolog 把记录变成age=1恢复如初

事务B也是提交事务的时候宕机，恢复时根据redo日志，可以直接恢复至`age=1`的初始状态。







可重复读：读的是事务开始数据快照的状态

不可重复读:读的是最新数据持久化的状态

幻读：和其它不一样的是，是针对增删而言的，比如事务A插入了一条记录id=5，事务B这个时候再插入相同的id=5的记录，就插入不成功，它就很纳闷

所以 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。



出现了幻读，那么不是说mysql的重复读解决了幻读的么？

准备的理解是，当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。

**结论：mysql 的重复读解决了幻读的现象，但是需要 加上 select for update/lock in share mode 变成当前读避免幻读，普通读select存在幻读**

但是重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。